#include "includes/minishell.h"
int	exit_code = 0;

t_mini	*init_mini(t_lexer *head, t_env *env)
{
	t_mini	*ptr;
	(void)env;
	char	**heredoc;

	ptr = ft_calloc(1, sizeof(t_mini));
	if (!ptr)
		return (NULL);
	ptr->args = head;
	ptr->nb_pipe = ft_nb_pipe(head);
	ptr->exec = init_exec(ptr);
	ptr->exec->data = ptr;
	ptr->env = env;
	heredoc = get_heredoc_tab(head);
	ptr->tab_heredoc = fill_heredoc_tab(heredoc, head);
	return (ptr);
}


t_lexer	*ft_parser_lexer(char *prompt, t_env *env)
{
	t_lexer	*head;

	head = ft_lexer(prompt);
	if (!head)
		return (NULL);
	if (quote_pars(head) == 0)
		return (free(prompt), ft_free_parser_lexer(head), NULL);
	ft_lexer_part_2(head, env);
	if (ft_parser(head) == -1)
		return (free(prompt), ft_free_parser_lexer(head), NULL);
	return (head);
}

void ft_handler(int i)
{
	if (i == SIGINT)
	{
		write(1, "\n", 1);
		rl_replace_line("", 0);
		rl_on_new_line();
		rl_redisplay();
	}
	else if (i == SIGQUIT)
		write(1, "\b\b  \b\b", 6);
}
int main(int ac, char **av, char **envp)
{
	char *prompt;
	(void)	av;
	(void)ac;
	t_lexer *list;
	// t_mini	*minish;
	t_env *minishell_env = set_env(envp);

	if (ac == 1)
	{
			signal(SIGINT, ft_handler);
			signal(SIGQUIT, ft_handler);
			while (42)
		{
			prompt = readline("minishell>");
			if (ft_prompt(prompt, minishell_env) == NULL)
				continue;
			list = ft_parser_lexer(ft_prompt(prompt, minishell_env), minishell_env);
			exit_code = 0;
			if (!list)
				continue;
			ft_unset_export_no_fork(list, minishell_env);
			ft_print_env(minishell_env);
			minish = init_mini(list, minishell_env);
			ft_pipex(minish->exec);
			ft_free_minishell_struct(minish, prompt);
			unlink("tmp.txt");
		}
	}
	
}
#include "../includes/minishell.h"

int	double_quote_validity_check(t_lexer *head)
{
	t_lexer *tmp;
	int		nb;

	nb = 1;
	tmp = head;
	while (tmp)
	{
		if (tmp->token == DOUBLE_QUOTE)
			nb++;
		tmp = tmp->next;
	}
	if (nb % 2 == 0 || nb == 0)
		return (1);
	return (0);
}

int	single_quote_state(t_lexer *head)
{
	t_lexer *tmp;
	int		len;

	tmp = head;
	while (tmp)
	{
		if (tmp->token == SINGLE_QUOTE && tmp->state == DEFAULT)
		{
			len = ft_strlen(tmp->str);
			if (len == 1)
				return (0);
			if (len > 2 && (tmp->str[0] != '\'' || tmp->str[len - 1] != '\''))
				return (0);
			if (len == 2 && tmp->str[1] == '\"')
				return (0);
		}
		tmp = tmp->next;
	}
	return (1);
}

int	quote_pars(t_lexer *head)
{
	if (single_quote_state(head) == 0)
		return (printf("minishell: syntax error near unexpected simple quote\n"), 0);
	if (double_quote_validity_check(head) == 1)
		return (printf("minishell: syntax error near unexpected double quote\n"), 0);
	return (1);
}#include "../includes/minishell.h"

char	*ft_give_val(t_env *env, char *name)
{
	t_env	*tmp;

	tmp = env;
	while (tmp)
	{
		if (ft_strncmp(tmp->var, name, ft_strlen(tmp->var)) == 0)
			return (ft_strdup(tmp->value));
		tmp = tmp->next;
	}
	return (NULL);
}

void	ft_replace_by_litteral(t_lexer *head, t_env *env)
{
	t_lexer	*tmp;
	char	*stock;

	tmp = head;
	while (tmp)
	{
		if (tmp->token == DOLLAR && tmp->dollar == COMPLEX && get_token_type(tmp->str[1]) == ALPHA_NUM)
		{
			stock = tmp->str;
			tmp->str = ft_give_val(env, tmp->str + 1);
			free(stock);
		}
		else if (tmp->token == DOLLAR && tmp->dollar == COMPLEX && tmp->str[1] == '$')
		{
			stock = tmp->str;
			tmp->str = ft_give_val(env, "SYSTEMD_EXEC_PID");
			free(stock);

		}
		else if (tmp->token == DOLLAR && tmp->dollar == COMPLEX && tmp->str[1] == '?')
		{
			stock = tmp->str;
			tmp->str = ft_itoa(exit_code);
			free(stock);
		}
		tmp = tmp->next;
	}
}
#include "../includes/minishell.h"

void	set_redirection_type(t_lexer *head)
{
	t_lexer *tmp;
	
	tmp = head;
	while (tmp)
	{
		if (ft_strcmp(tmp->str, ">>") == 0)
			tmp->token = DOUT;
		if (ft_strcmp(tmp->str, ">") == 0)
			tmp->token = OUT;
		if (ft_strcmp(tmp->str, "<") == 0)
			tmp->token = IN;
		if (ft_strcmp(tmp->str, "<<") == 0)
			tmp->token = DIN;
		tmp = tmp->next;
	}
}

void	ft_set_to_cmd(t_lexer *head)
{
	t_lexer *tmp;

	tmp = head;
	while (tmp)
	{
		if (tmp->i == 0 && tmp->token == WORD)
		tmp = tmp->next;
	}
}

void	ft_set_infile_outfile(t_lexer *head)
{
	t_lexer *tmp;

	tmp = head;
	while (tmp)
	{
		if (tmp->token == OUT || tmp->token == DOUT)
			if (tmp->next && tmp->next->token == WORD)
				tmp->next->token = OUTFILE;
		if (tmp->token == IN)
			if (tmp->next && tmp->next->token == WORD)
				tmp->next->token = INFILE;
		if (tmp->token == DIN)
			if (tmp->next && tmp->next->token == WORD)
				tmp->next->token = DELIMITER;
		tmp = tmp->next;
	}
}

#include "../includes/minishell.h"

int valid_pipe(t_lexer *head)
{
	t_lexer *tmp;

	tmp = head;
	while (tmp)
	{
		if (tmp->token == PIPE)
		{
			if (ft_strlen(tmp->str) > 1)
				return (-1);
			if ((tmp->prev && tmp->prev->token == PIPE)
				|| (tmp->next && tmp->next->token == PIPE))
				return (-1);
			if (tmp->next == NULL)
				return (-1);
		}
		tmp = tmp->next;
	}
	return (1);
}

int valid_simple_redirection(t_lexer *head)
{
	t_lexer *tmp;

	tmp = head;
	while (tmp)
	{
		if (tmp->token == REDIRECTION_RIGHT || tmp->token == REDIRECTION_LEFT)
		{
			if (ft_strlen(tmp->str) > 2)
				return (printf("minishell : syntax error near unexpected token `%s'\n", tmp->str + ft_strlen(tmp->str) - 2), -1);
			if (tmp->next && is_special_token(tmp->next) && ft_strlen(tmp->next->str) > 1)
				return (printf("minishell : syntax error near unexpected token `%s'\n", tmp->next->str + ft_strlen(tmp->next->str) - 2), -1);
			if (tmp->next && is_special_token(tmp->next))
				return (printf("minishell : syntax error near unexpected token `%s'\n", tmp->next->str), -1);
			if (tmp->next == NULL)
				return (printf("minishell : syntax error near unexpected token `newline'\n"), -1);
		}
		tmp = tmp->next;
	}
	return (1);
}

void	ft_heredoc_tokens(t_lexer *head)
{
	t_lexer *tmp;
	int		i;

	i = 0;
	tmp = head;
	while (tmp)
	{
		if (tmp->token == DIN && tmp->next && tmp->next->token == WORD)
		{
			tmp->next->token = DELIMITER;
			tmp->next->index_heredoc = i;
			i++;
		}
		tmp = tmp->next;
	}
}


int ft_parser(t_lexer *head)
{
	if (valid_pipe(head) == -1)
		return (printf("minishell syntax error near unexpected token `|'\n"), -1);
	if (valid_simple_redirection(head) == -1)
		return (-1);
	set_redirection_type(head);
	ft_set_infile_outfile(head);
	// ft_heredoc_tokens(head);
	return (1);
}




#include "../includes/minishell.h"

int	is_special_token(t_lexer *node)
{
	if (node->token == PIPE || node->token == REDIRECTION_LEFT || node->token == REDIRECTION_RIGHT)
		return (1);
	return (0);
}

int	ft_strcmp(char *s1, char *s2)
{
	int	i;

	if (!s1 || !s2)
		return (1);
	i = 0;
	while (s1[i] || s2[i])
	{
		if (s1[i] != s2[i])
			return (1);
		i++;
	}
	return (0);
}
char	*pars_prompt(char *str)
{
	int	i;

	i = 0;
	while (str[i] == ' ')
		i++;
	return (str + i);
}

int		ft_nb_pipe(t_lexer *head)
{
	int		count;

	count = 0;
	while (head)
	{
		if (head->token == PIPE)
			count++;
		head = head->next;
	}
	return (count);
}

char		*ft_prompt(char *prompt, t_env *env)
{
	char *prompt_without_spaces;

	if (prompt && prompt[0])
		add_history(prompt);
	// if (!(*prompt))
	// 	return (free(prompt), NULL);
	if (!prompt)
		return (ft_free_all_exit(env), NULL);
	prompt_without_spaces = pars_prompt(prompt);
	if (ft_strlen(prompt_without_spaces) == 0)
		return (free(prompt), NULL);
	return (prompt_without_spaces);
}
#include "../includes/minishell.h"


void	free_2darray(char	**split)
{
	int	size;
	int	i;

	i = 0;
	size = 0;
	while (split[size])
		size++;
	while (i < size)
		free(split[i++]);
	free(split);
	split = NULL;
}

char **ft_command(t_lexer *head)
{
	t_lexer *tmp;
	char    **tab;
	int     i;

	i = 0;
	tmp = head;
	while (tmp && tmp->token != PIPE)
	{
		if (tmp->token == WORD)
			i++;
		tmp = tmp->next;
	}
	if (i == 0)
		return (NULL);
	tmp = head;
	tab = ft_calloc(i + 1, sizeof(char *));
	if (!tab)
		return (NULL);
	i = 0;
	while (tmp && tmp->token != PIPE)
	{
		if (tmp->token == WORD)
		{
			tab[i] = ft_strdup(tmp->str);
			i++;
		}
		tmp = tmp->next;
	}
	tab[i] = NULL;
	return (tab);
}

char	*check_slash(char *command)
{
	if (ft_strchr(command, '/') && access(command, F_OK) == 0)
		return (ft_strdup(command));
	return (NULL);
}

char	**get_entire_path(char **envp)
{
	char	**paths = NULL;
	int		i;

	i = 0;
	while (envp[i] && !ft_strnstr(envp[i], "PATH", 4))
		i++;
	if (!ft_strnstr(envp[i], "PATH", 4))
		return (NULL);
	paths = ft_split(envp[i] + 5, ':');

	return (paths);
}

char	*ft_path(char *command, char **envp)
{
	char	**entire_path;
	char	*command_path;
	char	*add_slash;
	int		i;

	i = 0;
	if (ft_strchr(command, '/'))
		return (check_slash(command));
	entire_path = get_entire_path(envp);
	if (!entire_path)
		return (NULL);
	while (entire_path[i])
	{
		add_slash = ft_strjoin(entire_path[i], "/");
		command_path = ft_strjoin(add_slash, command);
		free(add_slash);
		if (access(command_path, F_OK) == 0)
		{
			free_2darray(entire_path);
			return (command_path);
		}
		free(command_path);
		i++;
	}
	free_2darray(entire_path);
	return (NULL);
}
#include "../includes/minishell.h"


char	*ft_strcat_env(char *s1, char *s2)
{
	char	*str;
	int		i;
	int		j;

	i = -1;
	j = -1;
	str = ft_calloc((ft_strlen(s1) + ft_strlen(s2) + 2), sizeof(char));
	if (!str)
		return (NULL);
	if (s1)
		while (s1[++i])
			str[i] = s1[i];
	str[i] = '=';
	i++;
	if (s2)
		while (s2[++j])
		{
			str[i] = s2[j];
			i++;
		}
	str[i] = '\0';
	return (str);
}


char **create_envp(t_env *env)
{
	t_env *tmp;
	char    **array;
	int     len;
	int		i;

	i = 0;
	len = 0;
	tmp = env;
	while (tmp)
	{
		len++;
		tmp = tmp->next;
	}
	array = ft_calloc(len + 1, sizeof(char *));
	if (!array)
		return (NULL);
	tmp = env;
	while (i <= len && tmp)
	{
		array[i] = ft_strcat_env(tmp->var, tmp->value);
		tmp = tmp->next;
		i++;
	}
	array[len] = NULL;
	return (array);
}

void	close_fds(int *fd)
{
	close(fd[0]);
	close(fd[1]);
}

int count_pipe(t_lexer *head)
{
	t_lexer *tmp;
	int		nb_pipe;

	nb_pipe = 0;
	tmp = head;
	while (tmp)
	{
		if (tmp->token == PIPE)
			nb_pipe++;
		tmp = tmp->next;
	}
	return (nb_pipe);
}

void    wait_all_pids(t_exec *args)
{
	int		i;

	i = 0;
	while (i < (args->data->nb_pipe + 1))
	{
		waitpid(args->pid[i], NULL, 0);
		i++;
	}
}

//calcule le nombre de pipe
//x#include "../includes/minishell.h"


void	ft_free_parser_lexer(t_lexer *pile)
{
	t_lexer	*tmp;

	tmp = pile;
	while (pile)
	{
		pile = pile->next;
		free(tmp->str);
		free(tmp);
		tmp = pile;
	}
}

void	ft_free_minishell_struct(t_mini *ptr, char *prompt)
{

	if (!ptr)
		return ;
	free(ptr->exec);
	if (ptr->tab_heredoc)
		ft_free_split(ptr->tab_heredoc);
	ft_free_parser_lexer(ptr->args);
	free(ptr);
	free(prompt);
	ptr = NULL;
}

void    ft_free_all(char *msg, t_exec *ptr)
{
	if (ptr->full_cmd)
		ft_free_split(ptr->full_cmd);
	if (ptr->full_cmd)
		ft_free_split(ptr->env);
	free(ptr->path);
	ptr->tmp = NULL;
	// if (ptr->data->exec)
	// 	free(ptr->data->exec);
	ft_free_parser_lexer(ptr->data->args);
	if (ptr)
		free(ptr);
    if (msg)
		perror(msg);
}

void	free_env(t_env *env)
{
	t_env	*tmp;

	tmp = env;
	while (env)
	{
		env = env->next;
		free(tmp->var);
		free(tmp->value);
		free(tmp);
		tmp = env;
	}
}

void	ft_free_all_exit(t_env *env)
{
	free_env(env);
	printf("\nexit\n");
	exit(0);
}#include "../includes/minishell.h"

int		write_expand(char *str, int fd, t_env *env)
{
	char	var[10000];
	char	*value;
	int	i;

	i = 1;
	if (!str)
		return (0);
	if (str[1] == '$' || ft_strlen(str) == 1)
		return (write(fd, "$", 1), 1);
	if ( str[1] && str[1] == '?')
	{
		value = ft_itoa(errno);
		ft_putstr_fd(value, fd);
		return (2);
	}
	while (str[i] && str[i] != ' ' && str[i] != '$' && ft_isalnum(str[i]))
		i++;
	ft_strlcpy(var, str + 1, i);
	value = ft_give_val(env, var);
	if (!value)
		return (i);
	ft_putstr_fd(value, fd);
	return (i);
}

char	**get_heredoc_tab(t_lexer *head)
{
	t_lexer	*tmp;
	int		i;
	char	**tab;

	i = 0;
	tmp = head;
	while (tmp)
	{
		if (tmp->token == DELIMITER)
		{
			tmp->index_heredoc = i;
			i++;
		}
		tmp = tmp->next;
	}
	if (i == 0)
		return (NULL);
	tab = ft_calloc(i + 1, sizeof(char *));
	if (!tab)
		return (NULL);
	return (tab);
}


void	ft_write_in_file(char *str_doc, int fd, t_env *env)
{
	char	**tab;
	int		i;
	int		j;

	i = 0;
	if (!str_doc)
		return ;
	tab = ft_split(str_doc, '\n');
	while (tab[i])
	{
		j = 0;
		while (tab[i][j])
		{
			if (tab[i][j] == '$')
			{
				j =  j + write_expand(tab[i] + j, fd, env);
				continue;
			}
			write(fd, &tab[i][j], 1);
			j++;
		}
		write(fd, "\n", 1);
		i++;
	}
}

char	*ft_get_heredoc(char *delimiter)
{
	char	*prompt = NULL;
	char	*heredoc = NULL;
	char	*tmp;

	while (1)
	{
		prompt = readline("heredoc>");
		if (ft_strcmp(prompt, delimiter) == 0)
			break;
		tmp = ft_strdup(prompt);
		tmp = ft_strjoin(tmp, "\n");
		if (!heredoc)
			heredoc = ft_strjoin("", tmp);
		else
			heredoc = ft_strjoin(heredoc, tmp);
		free(tmp);
		free(prompt);
	}
	return (heredoc);
}

char	**fill_heredoc_tab(char **tab, t_lexer *head)
{
	int	i;
	t_lexer	*tmp;

	if (!tab)
		return (NULL);
	tmp = head;
	i = 0;
	while (tmp)
	{
		if (tmp->token == DELIMITER)
		{
			tab[i] = ft_get_heredoc(tmp->str);
			i++;
		}
		tmp = tmp->next;
	}
	return (tab);
}
#include "../includes/minishell.h"

t_exec  *init_exec(t_mini *ptr)
{
	t_exec	*exe;

	exe = ft_calloc(1, sizeof(t_exec));
	if (!exe)
		return (NULL);
	exe->pid = ft_calloc(ptr->nb_pipe + 1, sizeof(pid_t));
	exe->prev = -1;
	return (exe);
}

t_lexer	*ret_next_pipe(t_lexer *head, int i)
{
	t_lexer *tmp;
	int		count_pipe;

	count_pipe = 0;
	tmp = head;
	if (i == 0)
		return (head);
	while (tmp)
	{
		if (tmp->token == PIPE)
		{
			count_pipe++;
			if (count_pipe == i)
				return (tmp->next);
		}
		tmp = tmp->next;
	}
	return (NULL);
}

int	set_exec(t_exec *ptr, int i, t_env *env)
{
	ptr->tmp = ret_next_pipe(ptr->data->args, i);
	ptr->full_cmd = ft_command(ptr->tmp);
	if (ptr->full_cmd)
	{
		ptr->cmd = ptr->full_cmd[0];
		ptr->env = create_envp(env);
		ptr->path = ft_path(ptr->cmd, ptr->env);
		if (ft_check_builtin(ptr->full_cmd) == -1 && !ptr->path) //check aussi si PATH existe, s'il existe il faut modifier l'erreur affichee en no such file or directory
		{
			ptr->path_split = get_entire_path(ptr->env);
			write(2, "minishell: ", 11);
			ft_putstr_fd(ptr->cmd, 2);
			if (!ptr->path_split)
				write(2, ": No such file or directory\n", 28);
			else
			{
				free(ptr->path_split);
				write(2, ": command not found\n", 20);
			}
			exit_code = 127;
			return (-1);
		}
	}
	return (1);
}

int	dup_close_fd_pipe(t_exec *ptr, int i)
{
	close(ptr->fd[0]);
	if (i == 0 && ptr->data->nb_pipe > 0)
	{
		if (dup2(ptr->fd[1], STDOUT_FILENO) == -1)
			return (-1);
		close(ptr->fd[1]);
	}
	else if (i != ptr->data->nb_pipe)
	{
		if (dup2(ptr->prev, STDIN_FILENO) == -1)
			return (-1);
		close(ptr->prev);
		if (dup2(ptr->fd[1], STDOUT_FILENO) == -1)
			return (-1);
		close(ptr->fd[1]);
	}
	if (i == ptr->data->nb_pipe && i > 0)
	{
		if (dup2(ptr->prev, STDIN_FILENO) == -1)
			return (-1);
		close(ptr->prev);
	}
	return (1);
}

void dupg(int in, int out)
{
	dup2(in, STDIN_FILENO);
	dup2(out, STDOUT_FILENO);
	close(in);
	close(out);
}
int 	ft_forking(t_exec *ptr, int i, t_env *env)
{
	int	builtin;

	if (set_exec(ptr, i, env) == -1)
		return (-1);
	if (dup_close_fd_pipe(ptr, i) == -1)
		return (exit_code = errno, -1);
	if (ft_redir(ptr) == -1)
		return (exit_code = errno, -1);
	builtin = ft_built_in(ptr->full_cmd, env);
	exit_code = 0;
	if (builtin == -1 && ptr->path && ptr->full_cmd && ptr->env)
		execve(ptr->path, ptr->full_cmd, ptr->env);
	ft_free_all(NULL, ptr);
	exit(0);
	return (1);
}


int	ft_pipex(t_exec *ptr)
{
	int	i;

	i = 0;
	while (i < (ptr->data->nb_pipe + 1))
	{
		pipe(ptr->fd);
		ptr->pid[i] = fork();
		if (ptr->pid[i] == 0)
		{
			if (ptr->data->nb_pipe == 0)
			{
				close(ptr->fd[1]);
				close(ptr->fd[0]);
			}
			if (ft_forking(ptr, i, ptr->data->env) != 1)
				return (free(ptr->pid), exit(0), -1);
		}
		else if (ptr->pid[i] > 0)
		{
			close(ptr->fd[1]);
			if (ptr->prev != -1)
				close(ptr->prev);
			ptr->prev = ptr->fd[0];
		}
		i++;
	}
	close(ptr->prev);
	wait_all_pids(ptr);
	free(ptr->pid);
	return (1);
}
#include "../includes/minishell.h"

int open_files(int  indice, char *path)
{
	int fd;

	if (indice == 1)
		fd = open(path, O_RDONLY);
	else if (indice == 2)
		fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, 0666);
	else if (indice == 3)
		fd = open(path, O_WRONLY | O_CREAT | O_APPEND, 0666);
	else if (indice == 4)
		fd = open("tmp.txt", O_RDWR | O_CREAT | O_TRUNC, 0644);
	else if (indice == 5)
		fd = open("tmp.txt", O_RDONLY);
	return (fd);
}

int	ft_open_dup_heredoc(t_lexer *head, t_exec *ptr)
{
	int	fd;

	fd = open_files(4, "");
	if ( fd == -1)
		return (perror("minishell"), -1);
	ft_write_in_file(ptr->data->tab_heredoc[head->index_heredoc], fd, ptr->data->env);
	close(fd);
	fd = open_files(5, "");
	if (fd == -1)
		return (-1);
	if (dup2(fd, STDIN_FILENO) == -1)
		return (perror("minishell"), close(fd), -1);
	close(fd);
	return (1);
}

int	ft_open(t_lexer *head, t_exec *ptr)
{
	if (!head)
		return (-1);
	if (ptr->redirect == IN)
	{
		if (ft_open_n_dup(1, head, ptr) == -1)
			return (perror("minishell"), -1);
	}
	else if (ptr->redirect == OUT)
	{
		if (ft_open_n_dup(2, head, ptr) == -1)
			return (-1);
	}
	else if (ptr->redirect == DOUT)
	{
		if (ft_open_n_dup(3, head, ptr) == -1)
			return (-1);
	}
	else if (ptr->redirect == HEREDOC)
	{
		if (ft_open_dup_heredoc(head, ptr) == -1)
			return (-1);
	}
	return (1);
}

int	ft_redir(t_exec *ptr)
{
	t_lexer *tmp = NULL;
	
	tmp = ft_next_redirection(ptr->tmp, ptr);
	if (!tmp)
		return (1);
	while (tmp)
	{
		if (ft_open(tmp, ptr) == -1)
			return (-1);
		tmp = ft_next_redirection(tmp->next, ptr);
	}
	return (1);
}

#include "../includes/minishell.h"

t_lexer *ft_next_redirection(t_lexer *head, t_exec *ptr)
{
	t_lexer *tmp;

	tmp = head;
	while (tmp && tmp->token != PIPE)
	{
		if (tmp->token == DELIMITER)
		{
			ptr->redirect = HEREDOC;
			return (tmp);
		}
		if (tmp->token == INFILE)
		{
			ptr->redirect = IN;
			return (tmp);
		}
		if (tmp->token == OUTFILE)
		{
			ptr->redirect = tmp->prev->token;
			return (tmp);
		}
		tmp = tmp->next;
	}
	return (NULL);
}

int	ft_open_n_dup(int indice, t_lexer *head, t_exec *ptr)
{
	int fd;
	(void)ptr;

	if (indice == 1)
	{
		fd = open_files(1, head->str);
		if (fd == -1)
			return (-1);
		if (dup2(fd, STDIN_FILENO) == -1)
			return(perror("minishell"), close(fd), -1);
	}
	else if (indice > 1)
	{
		fd = open_files(indice, head->str);
		if (fd == -1)
			return (-1);
		if (dup2(fd, STDOUT_FILENO) == -1)
			return(perror("minishell"), close(fd), -1);
	}
	close(fd);
	return (1);
}

#include "../includes/minishell.h"

int	verif_n(char *str)
{
	int	i;

	i = 0;
	if (!str)
		return (1);
	while (str[i])
	{
		if (str[i] != 'n')
			return (0);
		i++;
	}
	return (1);
}

void    ft_echo(char **args)
{
	int i;

	if (args[1] == NULL)
	{
		printf("\n");
		return ;
	}
	if (args[1] && (ft_strncmp(args[1], "-n", 2) == 0) && verif_n(args[1] + 2) == 1)
		i = 2;
	else
		i = 1;
	while (args[i])
	{
		printf("%s", args[i]);
		if (args[i + 1])
			printf(" ");
		i++;
	}
	if (ft_strcmp(args[1], "-n") != 0 && verif_n(args[1] + 2) == 0)
		printf("\n");
}#include "../includes/minishell.h"

t_env   *create_node(char *str_to_cpy)
{
	t_env	*node;
	int		i;
	int		j;

	i = 0;
	node = ft_calloc(1, sizeof(t_env));
	if (!node)
		return (NULL);
	while (str_to_cpy[i] && str_to_cpy[i] != '=')
		i++;
	j = i + 1;
	while (str_to_cpy[j])
		j++;
	node->var = ft_calloc(i + 1, sizeof(char));
	node->value = ft_calloc((j - i) + 1, sizeof(char));
	return (node);
}

void	cpy_tab(char *str, t_env *node)
{
	int		i;
	int		j;
	int		k;

	i = 0;
	k = 0;
	if (!node)
		return ;
	while (str[i] && str[i] != '=')
	{
		node->var[i] = str[i];
		i++;
	}
	str[i] = '\0';
	j = i + 1;
	while (str[j])
	{
		node->value[k] = str[j];
		j++;
		k++;
	}
	node->value[k] = '\0';
}

t_env	*add_to_list(t_env *head, t_env *new_node)
{
	t_env	*tmp;

	tmp = head;
	if (!head)
		return (new_node);
	while (tmp->next)
		tmp = tmp->next;
	tmp->next = new_node;
	return (head);
}

t_env	*set_env(char **envp)
{
	int		i;
	t_env	*head = NULL;
	t_env	*new;

	i = 0;
	while (envp[i])
	{
		new = create_node(envp[i]);
		cpy_tab(envp[i], new);
		head = add_to_list(head, new);
		i++;
	}
	return (head);
}

int		ft_print_env(t_env *env)
{
	if (!env)
		return (0);
	while (env)
	{
		printf("%s=%s\n", env->var, env->value);
		env = env->next;
	}
	return (1);
}#include "../includes/minishell.h"

void	ft_export(char *var, char *value, t_env *env)
{
	t_env	*tmp;
	t_env	*new;

	while (tmp)
	{
		if (ft_strncmp(var, tmp->var, sizeof(tmp)) == 0)
		{
			free(tmp->value);
			tmp->value = ft_strdup(value);
			return ;
		}
		tmp = tmp->next;
	}
	new = ft_calloc(1, sizeof(t_env));
	if (!new)
		return ;
	new->var = ft_strdup(var);
	new->value = ft_strdup(value);
	add_to_list(env, new);
}
#include "../includes/minishell.h"

int	ft_check_builtin(char **argv)
{
	if (ft_strcmp(argv[0], "echo") == 0)
		return (1);
	if (ft_strcmp(argv[0], "env") == 0)
		return (1);
	if (ft_strcmp(argv[0], "cd") == 0)
		return (1);
	if (ft_strcmp(argv[0], "unset") == 0)
		return (1);
	if (ft_strcmp(argv[0], "export") == 0)
		return (1);
	if (ft_strcmp(argv[0], "pwd") == 0)
		return (1);
	if (ft_strcmp(argv[0], "exit") == 0)
		return (1);
	return (-1);
}

int	ft_built_in(char **argv, t_env *env)
{
	if (!argv)
		return (-1);
	if (ft_strcmp(argv[0], "echo") == 0)
		return (ft_echo(argv), 1);
	if (ft_strcmp(argv[0], "env") == 0)
		return (ft_print_env(env), 1);
	if (ft_strcmp(argv[0], "cd") == 0)
		return (ft_cd(argv + 1), 1);
	if (ft_strcmp(argv[0], "pwd") == 0)
		return (ft_pwd(), 1);
	if (ft_strcmp(argv[0], "unset") == 0)
		return (1);
	return (-1);
}#include "../includes/minishell.h"

int	ft_cd(char **str)
{
	struct stat	stats;

	if (*str == NULL)
		return (chdir("/home/idris"), 1);
	if (str[1])
		return (printf("bash: cd: too many arguments\n"), 1);
	if (stat(*str, &stats))
		return (printf("bash: cd: "),perror(" \b"), 1);
	if (!S_ISDIR(stats.st_mode))
		return (printf("bash: cd: "),printf(": Not a directory\n"), 1);
	else if (chdir(*str) == -1)
		return (printf("bash: cd: "),
			perror(" \b"), 1);
	return (0);
}
#include "../includes/minishell.h"

int		ft_pwd(void)
{
	char	cwd[1024];
	if (!getcwd(cwd, sizeof(cwd)))
		return (perror(""), 0);
	printf("%s\n", cwd);
	return (1);
}#include "../includes/minishell.h"

void	ft_delete_node(t_env **env, t_env *node)
{
	t_env	*tmp;

	tmp = *env;
	if (node->var)
		free(node->var);
	if (node->value)
		free(node->value);
	if (*env == node)
	{
		*env = (*env)->next;
		free(node);
	}
	else if (tmp != node)
	{
		
		while (tmp && tmp->next != node)
			tmp = tmp->next;
		tmp->next = node->next;
		free(node);
	}
}


void	ft_unset(t_env *env, char **argv)
{
	int		i;
	t_env	*tmp;

	i = 1;
	while (argv[i])
	{
		tmp = env;
		while (tmp)
		{
			if (ft_strcmp(argv[i], tmp->var) == 0)
			{
				ft_delete_node(&env, tmp);
				break;
			}
			tmp = tmp->next;
		}
		i++;
	}
}


void	ft_unset_export_no_fork(t_lexer *args, t_env *env)
{
	char	**argv;

	argv = ft_command(args);
	if (ft_strcmp(argv[0], "unset") == 0)
		ft_unset(env, argv);
}
